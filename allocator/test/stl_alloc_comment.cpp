template <int __inst>		//虽然有个模版参数，但是实际没用到，对应第4点class __malloc_alloc_template {private:  //两个处理内存不足的函数指针，模拟了c++，new-handler机制  static void* _S_oom_malloc(size_t);  static void* _S_oom_realloc(void*, size_t);  static void (* __malloc_alloc_oom_handler)();public:  //分配空间  static void* allocate(size_t __n)  {    void* __result = malloc(__n);//直接malloc,返回void*    if (0 == __result) __result = _S_oom_malloc(__n);	//分配失败，调用_S_oom_malloc来分配    return __result;  }  //释放空间  static void deallocate(void* __p, size_t /* __n */)  {    free(__p);//直接free  }  //按制定大小重分配  static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)  {    void* __result = realloc(__p, __new_sz);    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);//失败，调用_S_oom_realloc来分配    return __result;  }  //处理内存不足，模拟set_new_handler()  static void (* __set_malloc_handler(void (*__f)()))()  {    void (* __old)() = __malloc_alloc_oom_handler;    __malloc_alloc_oom_handler = __f;    return(__old);  }};// malloc_alloc out-of-memory handling//初值设为0，用户调整template <int __inst>void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;//处理malloc内存不足问题template <int __inst>void* __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n){    void (* __my_malloc_handler)();    void* __result;    for (;;) {		//不断尝试        __my_malloc_handler = __malloc_alloc_oom_handler;        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }//用户没设定，实在不行，抛出异常        (*__my_malloc_handler)();        __result = malloc(__n);		//分配内存        if (__result) return(__result);    }}//处理realloc内存不足问题template <int __inst>void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n){    void (* __my_malloc_handler)();    void* __result;    for (;;) {		//不断尝试        __my_malloc_handler = __malloc_alloc_oom_handler;        if (0 == __my_malloc_handler) { __THROW_BAD_ALLOC; }//用户没设定，抛出异常        (*__my_malloc_handler)();        __result = realloc(__p, __n);//再尝试        if (__result) return(__result);    }}//相当于实例化，_inst没啥实际含义typedef __malloc_alloc_template<0> malloc_alloc;//template<class _Tp, class _Alloc>class simple_alloc {public:    static _Tp* allocate(size_t __n)      { return 0 == __n ? 0 : (_Tp*) _Alloc::allocate(__n * sizeof (_Tp)); }    static _Tp* allocate(void)      { return (_Tp*) _Alloc::allocate(sizeof (_Tp)); }    static void deallocate(_Tp* __p, size_t __n)      { if (0 != __n) _Alloc::deallocate(__p, __n * sizeof (_Tp)); }    static void deallocate(_Tp* __p)      { _Alloc::deallocate(__p, sizeof (_Tp)); }};